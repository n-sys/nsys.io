using System;
using System.IO;
using System.Collections.Generic;
using Grpc.Core;
using Nsys.Api.Ntypes;
using Nsys.Api.Image;
using Nsys.Api.Exemplar;

namespace ScanDemo
{
    /// <summary>
    /// This is a demo program which uploads an exemplar or a scan.
    /// If an exemplar is uploaded it optionally creates a signature present field with either a
    /// rectangle or a rotated rectangle.
    ///
    /// If a scan is uploaded, it is deskewed and registered against any exemplars in the
    /// system under the account associated with the api key. The base, deskewed, and registered
    /// images are all saved to disk. Then all fields are solved and the solutions are printed to
    /// the console. The field cut images are also saved to disk.
    ///
    /// The following rpcs from the image service are demonstrated:
    ///   UploadImage
    ///   RegisterImage
    ///   GetBaseImage
    ///   GetDeskewedImage
    ///   GetRegisteredImage
    ///   GetExemplarSnapshot
    ///   SolveField
    ///   GetFieldCut
    ///   ListSolvedFields
    ///   GetFieldSolutions
    ///
    /// The following rpcs from the exemplar service are demonstrated:
    ///   UploadPdf
    ///   CreateExemplar
    ///   CreateField
    /// </summary>
    class Program
    {
        /// <summary>
        /// Main parses the command line arguments and either runs the exemplar upload, or the scan
        /// demo.
        /// </summary>
        static void Main(string[] args)
        {
            var usage = @"Usage:
  [api_key] [scan_filename/exemplar_pdf_filename] [opt scan/exemplar name/id]
  [opt fieldVals: (fieldID, x, y, w, h) or (fieldID, centerX, centerY, w, h, angle)]

  If the filename has a pdf extension it will create an exemplar from the first page.
  Otherwise it will run the scan demo. In both cases you can provide an optional name or
  id, if none is provided one will be autogenerated.

  If you upload a pdf as an exemplar you can optionally create a field. But in this case
  ALL optional arguments are required.

Example Usages (make sure to replace APIKEY with your own key):

1. Create an exemplar without any fields:

    dotnet run APIKEY exemplar.pdf

  Where exemplar.pdf is the filename of the pdf that will be uploaded. The first page of
  the pdf will be turned into an exemplar, and in this case the system will auto-create a
  name for it.

2. Create an exemplar with a signature field using a regular rectangle:

    dotnet run APIKEY exemplar.pdf my_exemp my_sig_field 4.0 5.0 7.0, 3.0

  In this case it will create an exemplar with a name/id of ""my_exemp"". A signature field
  will be created with the name/id of ""my_sig_field"". It will be defined by a regular
  rectangle with the TOP LEFT point at (4.0, 5.0) cms, and a width and height of 7.0 and
  3.0 cms respectively.

3. Create an exemplar with a signature field using a rotated rectangle:

    dotnet run APIKEY exemplar.pdf my_exemp my_sideways_sig 5.0 2.0 7.0 3.0 45.0

  In this case it will create an exemplar named ""my_exemp"" with a field called
  ""my_sideways_sig"". The CENTER of the rotated rectangle will be at (5.0, 2.0) cms, and
  will have a width and height of 7.0 and 3.0 cms respectively. The rectangle will be
  rotated by 45 degrees clockwise so the signature baseline will be on the south-west
  side.

4. Run the scan demo on an image:

    dotnet run APIKEY scan.jpg

  Where scan.jpg is the filename of the image to be uploaded. The name/id will be
  autogenerated. The scan will be deskewed and registered against any known exemplar. If
  matched with an exemplar all fields on the exemplar will be solved.";

            if (args.Length < 2 || (args.Length > 3 && (args.Length != 8 && args.Length != 9)))
            {
                Console.WriteLine(usage);
                return;
            }
            var apiKey = args[0];
            var inputFilename = args[1];
            string name = "";
            if (args.Length > 2) name = args[2];
            double x = 0, y = 0, w = 0, h = 0, a = 0;
            string fieldName = "";
            if (args.Length > 3)
            {
                fieldName = args[3];
                x = double.Parse(args[4]);
                y = double.Parse(args[5]);
                w = double.Parse(args[6]);
                h = double.Parse(args[7]);
            }
            if (args.Length == 9)
            {
                a = double.Parse(args[8]);
            }

            var channel = GetGrpcChannel();
            var reqHead = new Metadata { { "x-api-key", apiKey } };

            if (Path.GetExtension(inputFilename).ToLower() == ".pdf")
            {
                UploadExemplar(channel, reqHead, inputFilename, name, fieldName, x, y, w, h, a);
            }
            else
            {
                ScanDemo(channel, reqHead, inputFilename, name);
            }
            channel.ShutdownAsync().Wait();
        }

        /// <summary>
        /// GetGrpcChannel returns a grpc channel connected to the nsys server.
        /// It uses tls signed by the server side and sets the message length limits.
        /// </summary>
        static Channel GetGrpcChannel()
        {
            var host = "api.nsys.io";
            var port = 39111;
            var channelOptions = new List<ChannelOption>
            {
                new ChannelOption(ChannelOptions.SslTargetNameOverride, host),
                new ChannelOption(ChannelOptions.MaxReceiveMessageLength, 50*1024*1024),
                new ChannelOption(ChannelOptions.MaxSendMessageLength, 50*1024*1024),
            };
            return new Channel(host, port, new SslCredentials(), channelOptions);
        }

        /// <summary>
        /// UploadExemplar uploads a pdf and registers the first page as an exemplar.
        /// </summary>
        static void UploadExemplar(Channel chan, Metadata reqHead,
                                   string filename, string exempName, string fieldName,
                                   double x, double y, double w, double h, double a)
        {
            var fileBytes = File.ReadAllBytes(filename);
            var client = new Exemplars.ExemplarsClient(chan);

            // upload the pdf
            var uploadPdfReq = new UploadPdfRequest
            {
                Data = Google.Protobuf.ByteString.CopyFrom(fileBytes),
                Language = Language.English
            };
            uploadPdfReq.PageNumbers.Add(1);
            var uploadPdfRes = client.UploadPdf(uploadPdfReq, reqHead);
            Console.WriteLine("Uploaded pdf:");
            Console.WriteLine("  " + uploadPdfRes);

            // create the exemplar
            var createExemplarReq = new CreateExemplarRequest
            {
                Name = exempName,
                ImageOrPdfName = uploadPdfRes.Name,
                PageNumber = 1
            };
            var createExemplarRes = client.CreateExemplar(createExemplarReq, reqHead);
            Console.WriteLine("Created exemplar:");
            Console.WriteLine("  " + createExemplarRes);

            // if the field name is empty, we're going to quit
            if (fieldName == "") return;

            SignaturePresentPuzzle sigPresentPuz;
            if (a == 0)
            {
                // angle is zero so we'll make a signature puzzle with a regular rectangle.
                sigPresentPuz = new SignaturePresentPuzzle
                {
                    Rect = new Rectangle
                    {
                        MinX = x,
                        MinY = y,
                        MaxX = x + w,
                        MaxY = y + h
                    }
                };
            }
            else
            {
                // angle is not zero so we'll make a signature puzzle with a rotated rectangle.
                sigPresentPuz = new SignaturePresentPuzzle
                {
                    RotatedRect = new RotatedRectangle
                    {
                        Center = new Point { X = x, Y = y },
                        Size = new Size { Width = w, Height = h },
                        Angle = a
                    }
                };
            }

            var createFieldReq = new CreateFieldRequest
            {
                ExemplarName = createExemplarRes.Name,
                Field = new Field
                {
                    Name = fieldName,
                    SignaturePresent = sigPresentPuz
                }
            };
            var createFieldRes = client.CreateField(createFieldReq, reqHead);
            Console.WriteLine("Created field on exemplar:");
            Console.WriteLine("  " + createFieldRes);
        }

        /// <summary>
        /// ScanDemo uploads a scan to the system and registers it to an exemplar. It also
        /// downloads all the images in between (the base image, the deskewed image, the
        /// registered image, and finally the reference exemplar image).
        /// </summary>
        static void ScanDemo(Channel chan, Metadata reqHead, string filename, string name)
        {
            var fileBytes = File.ReadAllBytes(filename);

            var client = new ImageProcessing.ImageProcessingClient(chan);

            // setup the upload image request
            var uploadImgReq = new UploadImageRequest
            {
                Name = name,
                Image = new Image
                {
                    Data = Google.Protobuf.ByteString.CopyFrom(fileBytes),
                    Encoding = ImageEncodingFromFilename(filename)
                },
                ImageSource = ImageSource.Scanner,
            };

            // upload the image:
            var uploadImgRes = client.UploadImage(uploadImgReq, reqHead);
            Console.WriteLine("UploadImageResponse:");
            Console.WriteLine("  " + uploadImgRes);

            // save the uploaded image name to use in the following requests
            name = uploadImgRes.Name;

            // lets the base image back:
            var getBaseImgReq = new GetBaseImageRequest { ImageName = name };
            var getBaseImgRes = client.GetBaseImage(getBaseImgReq, reqHead);
            var baseImg = getBaseImgRes.BaseImage; // the base image in the response
            var baseFNBase = AddExt(name + "-00-baseImage", baseImg.Encoding);
            File.WriteAllBytes(baseFNBase, baseImg.Data.ToByteArray());
            Console.WriteLine("GetBaseImageResponse:");
            Console.WriteLine("  Output:   " + baseFNBase);

            // lets get the deskewed image back:
            var getDeskewedReq = new GetDeskewedImageRequest { ImageName = name };
            var getDeskewedRes = client.GetDeskewedImage(getDeskewedReq, reqHead);
            var deskewedImg = getDeskewedRes.DeskewedImage; // the deskewed image
            var deskewedFNBase = AddExt(name + "-01-deskewedImage", deskewedImg.Image.Encoding);
            File.WriteAllBytes(deskewedFNBase, deskewedImg.Image.Data.ToByteArray());
            Console.WriteLine("GetDeskewedImageResponse:");
            Console.WriteLine("  Angle:    " + deskewedImg.DeskewAngle);
            Console.WriteLine("  Rotation: " + deskewedImg.DegreesRotated);
            Console.WriteLine("  Color:    " + deskewedImg.BackgroundColor);
            Console.WriteLine("  Output:   " + deskewedFNBase);

            // lets register the image:
            var regImgReq = new RegisterImageRequest { ImageName = name };
            var regImgRes = client.RegisterImage(regImgReq, reqHead);
            Console.WriteLine("RegisterImageResponse:");
            Console.WriteLine("  " + regImgRes);

            // if it failed to match then we're done
            if (regImgRes.NoMatch) return;

            // lets get the registered image:
            var getRegImgReq = new GetRegisteredImageRequest { ImageName = name };
            var getRegImgRes = client.GetRegisteredImage(getRegImgReq, reqHead);
            var regImg = getRegImgRes.Image;
            var registeredImgFN = AddExt(name + "-02-registeredImage", regImg.Image.Encoding);
            File.WriteAllBytes(registeredImgFN, regImg.Image.Data.ToByteArray());
            Console.WriteLine("GetRegisteredImageResponse:");
            Console.WriteLine("  Size:   " + regImg.Size);
            Console.WriteLine("  Output: " + registeredImgFN);

            // lets get the exemplar snapshot:
            var getSnapshotReq = new GetExemplarSnapshotRequest
            {
                ImageName = name,
                ReturnImageData = true // if false, will return snapshot without image data.
            };
            var getSnapshotRes = client.GetExemplarSnapshot(getSnapshotReq, reqHead);
            var snapshot = getSnapshotRes.ExemplarSnapshot;
            var snapshotFN = name + "-03-exemplar.png";
            File.WriteAllBytes(snapshotFN, snapshot.PngData.ToByteArray());
            Console.WriteLine("GetExemplarSnapshotResponse:");
            Console.WriteLine("  Name:        " + snapshot.Name);
            Console.WriteLine("  Description: " + snapshot.Description);
            Console.WriteLine("  CreateTime:  " + snapshot.CreateTime);
            Console.WriteLine("  Metadata:    " + snapshot.Metadata);
            Console.WriteLine("  Size:        " + snapshot.Size);
            Console.WriteLine("  Fields:      " + snapshot.Fields);
            Console.WriteLine("  Output:      " + snapshotFN);

            // solve all the fields on this image
            foreach (var field in snapshot.Fields)
            {
                var solveReq = new SolveFieldRequest
                {
                    ImageName = name,
                    FieldName = field.Name
                };
                var solveRes = client.SolveField(solveReq, reqHead);
                Console.WriteLine("SolveFieldResponse:");
                Console.WriteLine("  " + solveRes);

                // while we're at it, let's get the cuts and save them as image files
                GetFieldCut(client, reqHead, name, field.Name);
            }

            // let's list all the solved fields:
            var listSolvedFieldsReq = new ListSolvedFieldsRequest { ImageName = name };
            var listSolvedFieldsRes = client.ListSolvedFields(listSolvedFieldsReq, reqHead);
            var solvedFields = listSolvedFieldsRes.FieldNames;
            Console.WriteLine("ListSolvedFieldsResponse: " + solvedFields.Count);
            foreach (var f in solvedFields) Console.WriteLine("  " + f);

            // now get all the solved solutions:
            var getSolReq = new GetFieldSolutionsRequest
            {
                ImageName = name,
                FieldNames = { solvedFields } // give it the list of known solved fields
            };                                // from the request above.
            var getSolRes = client.GetFieldSolutions(getSolReq, reqHead);
            var solutions = getSolRes.FieldSolutions;
            Console.WriteLine("GetFieldSolutionsResponse: " + solutions.Count);
            foreach (var fs in solutions) Console.WriteLine("  " + fs);
        }

        /// <summary>
        /// GetFieldCut gets a field cut for the given image and field name.
        /// It saves the field cuts as images files.
        /// </summary>
        static void GetFieldCut(ImageProcessing.ImageProcessingClient client, Metadata reqHead,
                                string imageName, string fieldName)
        {
            var getCutReq = new GetFieldCutRequest
            {
                ImageName = imageName,
                FieldName = fieldName
            };
            var getCutRes = client.GetFieldCut(getCutReq, reqHead);
            Console.WriteLine("GetFieldCutResponse: ");
            Console.WriteLine("  FieldCutCase:  " + getCutRes.FieldCut.FieldCutCase);
            switch (getCutRes.FieldCut.FieldCutCase)
            {
                case FieldCut.FieldCutOneofCase.SignaturePresent:
                    // Signature present puzzles have two cuts, a "raw" cut and a "context" cut,
                    // let's save both of them:
                    var sigcut = getCutRes.FieldCut.SignaturePresent;
                    var rawCutFN = imageName + "-" + fieldName + "-sig-raw.png";
                    var ctxCutFN = imageName + "-" + fieldName + "-sig-ctx.png";
                    File.WriteAllBytes(rawCutFN, sigcut.RawCut.Image.Data.ToByteArray());
                    File.WriteAllBytes(ctxCutFN, sigcut.ContextCut.Image.Data.ToByteArray());
                    Console.WriteLine("  RawCut Output: " + rawCutFN);
                    Console.WriteLine("  CxtCut Output: " + ctxCutFN);
                    break;
                case FieldCut.FieldCutOneofCase.HandwritingPresent:
                    // Handwriting Present puzzles have a single cut, we'll save it to disk
                    var handcut = getCutRes.FieldCut.HandwritingPresent;
                    rawCutFN = imageName + "-" + fieldName + "-hndwrt-raw.png";
                    File.WriteAllBytes(rawCutFN, handcut.RawCut.Image.Data.ToByteArray());
                    Console.WriteLine("  RawCut Output: " + rawCutFN);
                    break;
                case FieldCut.FieldCutOneofCase.None: // fallthrough to default case
                default:
                    Console.WriteLine("  ERROR, FieldCut not available");
                    break;
            }
        }

        /// <summary>
        /// ImageEncodingFromFilename is a simple helper function to get the image encoding from a
        /// filename extension.
        /// </summary>
        static ImageEncoding ImageEncodingFromFilename(string filename)
        {
            var ext = Path.GetExtension(filename).ToLower();
            if (ext == ".png") return ImageEncoding.Png;
            if (ext == ".jpg" || ext == ".jpeg") return ImageEncoding.Jpeg;
            if (ext == ".tif" || ext == ".tiff") return ImageEncoding.Tiff;
            return ImageEncoding.Invalid;
        }

        /// <summary>
        /// AddExt is a simple helper function that adds the appropriate file extension to a
        /// filename given the image encoding.
        /// </summary>
        static string AddExt(string filename, ImageEncoding encoding)
        {
            if (encoding == ImageEncoding.Jpeg) return filename + ".jpg";
            if (encoding == ImageEncoding.Tiff) return filename + ".tif";
            if (encoding == ImageEncoding.Png) return filename + ".png";
            return filename + ".invalid.img";
        }
    }
}
