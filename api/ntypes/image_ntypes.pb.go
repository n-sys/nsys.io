// Code generated by protoc-gen-go. DO NOT EDIT.
// source: image_ntypes.proto

package ntypes

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ImageSource int32

const (
	// Automatically determine the image type.
	ImageSource_AUTO ImageSource = 0
	// Image originated from a generic scanner of some sort. DPI unknown.
	ImageSource_SCANNER ImageSource = 1
	// Image is 300dpi JPEG2000 originating from our PDS-6000 based system.
	ImageSource_SCANNER_NSYS ImageSource = 2
	// Image is a raw photograph which likely needs document isolation and
	// perspective correction in addition to deskew and orienting.
	// If photo originated from scanner app or similar that does the first
	// two already, use "auto" instead.
	ImageSource_PHOTO ImageSource = 3
)

var ImageSource_name = map[int32]string{
	0: "AUTO",
	1: "SCANNER",
	2: "SCANNER_NSYS",
	3: "PHOTO",
}

var ImageSource_value = map[string]int32{
	"AUTO":         0,
	"SCANNER":      1,
	"SCANNER_NSYS": 2,
	"PHOTO":        3,
}

func (x ImageSource) String() string {
	return proto.EnumName(ImageSource_name, int32(x))
}

func (ImageSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{0}
}

type ImageEncoding int32

const (
	ImageEncoding_INVALID ImageEncoding = 0
	ImageEncoding_JPEG    ImageEncoding = 1
	ImageEncoding_PNG     ImageEncoding = 2
	ImageEncoding_TIFF    ImageEncoding = 3
)

var ImageEncoding_name = map[int32]string{
	0: "INVALID",
	1: "JPEG",
	2: "PNG",
	3: "TIFF",
}

var ImageEncoding_value = map[string]int32{
	"INVALID": 0,
	"JPEG":    1,
	"PNG":     2,
	"TIFF":    3,
}

func (x ImageEncoding) String() string {
	return proto.EnumName(ImageEncoding_name, int32(x))
}

func (ImageEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{1}
}

type Language int32

const (
	Language_UNKNOWN Language = 0
	Language_ENGLISH Language = 1
	Language_SPANISH Language = 2
	Language_GERMAN  Language = 3
	Language_FRENCH  Language = 4
)

var Language_name = map[int32]string{
	0: "UNKNOWN",
	1: "ENGLISH",
	2: "SPANISH",
	3: "GERMAN",
	4: "FRENCH",
}

var Language_value = map[string]int32{
	"UNKNOWN": 0,
	"ENGLISH": 1,
	"SPANISH": 2,
	"GERMAN":  3,
	"FRENCH":  4,
}

func (x Language) String() string {
	return proto.EnumName(Language_name, int32(x))
}

func (Language) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{2}
}

type Image struct {
	// The encoded image data bytes.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// The image encoding.
	Encoding             ImageEncoding `protobuf:"varint,2,opt,name=encoding,proto3,enum=nsys.api.ntypes.ImageEncoding" json:"encoding,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{0}
}

func (m *Image) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Image.Unmarshal(m, b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Image.Marshal(b, m, deterministic)
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return xxx_messageInfo_Image.Size(m)
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Image) GetEncoding() ImageEncoding {
	if m != nil {
		return m.Encoding
	}
	return ImageEncoding_INVALID
}

type DeskewedImage struct {
	// An image that the nsys service has deskewed and oriented.
	Image *Image `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Clockwise degrees the image had to be rotated to bring text lines
	// into a horizontal or vertical orientation.
	DeskewAngle float64 `protobuf:"fixed64,2,opt,name=deskew_angle,json=deskewAngle,proto3" json:"deskew_angle,omitempty"`
	// 0, 90, 180, or 270. The rotation that had to performed to bring
	// the text lines into an upright and horizontal orientation.
	DegreesRotated int32 `protobuf:"varint,3,opt,name=degrees_rotated,json=degreesRotated,proto3" json:"degrees_rotated,omitempty"`
	// The dominant color of the image. Probably.
	BackgroundColor      *RGBA    `protobuf:"bytes,4,opt,name=background_color,json=backgroundColor,proto3" json:"background_color,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeskewedImage) Reset()         { *m = DeskewedImage{} }
func (m *DeskewedImage) String() string { return proto.CompactTextString(m) }
func (*DeskewedImage) ProtoMessage()    {}
func (*DeskewedImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{1}
}

func (m *DeskewedImage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeskewedImage.Unmarshal(m, b)
}
func (m *DeskewedImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeskewedImage.Marshal(b, m, deterministic)
}
func (m *DeskewedImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeskewedImage.Merge(m, src)
}
func (m *DeskewedImage) XXX_Size() int {
	return xxx_messageInfo_DeskewedImage.Size(m)
}
func (m *DeskewedImage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeskewedImage.DiscardUnknown(m)
}

var xxx_messageInfo_DeskewedImage proto.InternalMessageInfo

func (m *DeskewedImage) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *DeskewedImage) GetDeskewAngle() float64 {
	if m != nil {
		return m.DeskewAngle
	}
	return 0
}

func (m *DeskewedImage) GetDegreesRotated() int32 {
	if m != nil {
		return m.DegreesRotated
	}
	return 0
}

func (m *DeskewedImage) GetBackgroundColor() *RGBA {
	if m != nil {
		return m.BackgroundColor
	}
	return nil
}

type DimensionedImage struct {
	// An image where the physical real-world dimensions are known.
	// All elements of this message are required and must be set.
	Image *Image `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Dimensions of the image in centimeters.
	Size *Size `protobuf:"bytes,2,opt,name=size,proto3" json:"size,omitempty"`
	// Top left offset of the image. Very likely to be zero unless it's a cut.
	Offset               *Point   `protobuf:"bytes,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DimensionedImage) Reset()         { *m = DimensionedImage{} }
func (m *DimensionedImage) String() string { return proto.CompactTextString(m) }
func (*DimensionedImage) ProtoMessage()    {}
func (*DimensionedImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{2}
}

func (m *DimensionedImage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DimensionedImage.Unmarshal(m, b)
}
func (m *DimensionedImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DimensionedImage.Marshal(b, m, deterministic)
}
func (m *DimensionedImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionedImage.Merge(m, src)
}
func (m *DimensionedImage) XXX_Size() int {
	return xxx_messageInfo_DimensionedImage.Size(m)
}
func (m *DimensionedImage) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionedImage.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionedImage proto.InternalMessageInfo

func (m *DimensionedImage) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *DimensionedImage) GetSize() *Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *DimensionedImage) GetOffset() *Point {
	if m != nil {
		return m.Offset
	}
	return nil
}

type RGBA struct {
	// RGBA color
	R                    uint32   `protobuf:"varint,1,opt,name=r,proto3" json:"r,omitempty"`
	G                    uint32   `protobuf:"varint,2,opt,name=g,proto3" json:"g,omitempty"`
	B                    uint32   `protobuf:"varint,3,opt,name=b,proto3" json:"b,omitempty"`
	A                    uint32   `protobuf:"varint,4,opt,name=a,proto3" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RGBA) Reset()         { *m = RGBA{} }
func (m *RGBA) String() string { return proto.CompactTextString(m) }
func (*RGBA) ProtoMessage()    {}
func (*RGBA) Descriptor() ([]byte, []int) {
	return fileDescriptor_60e11bd6be6721a1, []int{3}
}

func (m *RGBA) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RGBA.Unmarshal(m, b)
}
func (m *RGBA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RGBA.Marshal(b, m, deterministic)
}
func (m *RGBA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RGBA.Merge(m, src)
}
func (m *RGBA) XXX_Size() int {
	return xxx_messageInfo_RGBA.Size(m)
}
func (m *RGBA) XXX_DiscardUnknown() {
	xxx_messageInfo_RGBA.DiscardUnknown(m)
}

var xxx_messageInfo_RGBA proto.InternalMessageInfo

func (m *RGBA) GetR() uint32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *RGBA) GetG() uint32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *RGBA) GetB() uint32 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *RGBA) GetA() uint32 {
	if m != nil {
		return m.A
	}
	return 0
}

func init() {
	proto.RegisterEnum("nsys.api.ntypes.ImageSource", ImageSource_name, ImageSource_value)
	proto.RegisterEnum("nsys.api.ntypes.ImageEncoding", ImageEncoding_name, ImageEncoding_value)
	proto.RegisterEnum("nsys.api.ntypes.Language", Language_name, Language_value)
	proto.RegisterType((*Image)(nil), "nsys.api.ntypes.Image")
	proto.RegisterType((*DeskewedImage)(nil), "nsys.api.ntypes.DeskewedImage")
	proto.RegisterType((*DimensionedImage)(nil), "nsys.api.ntypes.DimensionedImage")
	proto.RegisterType((*RGBA)(nil), "nsys.api.ntypes.RGBA")
}

func init() { proto.RegisterFile("image_ntypes.proto", fileDescriptor_60e11bd6be6721a1) }

var fileDescriptor_60e11bd6be6721a1 = []byte{
	// 494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x52, 0x5f, 0x8f, 0xd2, 0x4e,
	0x14, 0xdd, 0x81, 0xf2, 0xe7, 0x77, 0xa1, 0xcb, 0x64, 0xf2, 0xd3, 0x10, 0x1f, 0x0c, 0xcb, 0x8b,
	0x48, 0x4c, 0x49, 0xd6, 0x27, 0x7d, 0x30, 0x76, 0xa1, 0x40, 0x15, 0x07, 0x32, 0x65, 0xdd, 0xe8,
	0x0b, 0x19, 0xe8, 0x6c, 0xd3, 0xec, 0x32, 0x43, 0xda, 0x12, 0xc3, 0x7e, 0x15, 0x3f, 0x92, 0x5f,
	0xca, 0xcc, 0x0c, 0xd1, 0xe8, 0xf2, 0xe4, 0x5b, 0xcf, 0xc9, 0xb9, 0xe7, 0x9c, 0x3b, 0xbd, 0x40,
	0xd2, 0x2d, 0x4f, 0xc4, 0x4a, 0x16, 0x87, 0x9d, 0xc8, 0xbd, 0x5d, 0xa6, 0x0a, 0x45, 0x5a, 0x32,
	0x3f, 0xe4, 0x1e, 0xdf, 0xa5, 0x9e, 0xa5, 0x9f, 0x5d, 0x18, 0x22, 0x55, 0x03, 0xbe, 0x4b, 0x07,
	0x96, 0x1b, 0x24, 0x42, 0x6d, 0x45, 0x91, 0x1d, 0xec, 0x4c, 0xf7, 0x06, 0x2a, 0xa1, 0x76, 0x22,
	0x04, 0x9c, 0x98, 0x17, 0xbc, 0x8d, 0x3a, 0xa8, 0xd7, 0x64, 0xe6, 0x9b, 0xbc, 0x85, 0xba, 0x90,
	0x1b, 0x15, 0xa7, 0x32, 0x69, 0x97, 0x3a, 0xa8, 0x77, 0x7e, 0xf9, 0xdc, 0xfb, 0x2b, 0xc3, 0x33,
	0xd3, 0xc1, 0x51, 0xc5, 0x7e, 0xe9, 0xbb, 0x3f, 0x10, 0xb8, 0x23, 0x91, 0xdf, 0x89, 0x6f, 0x22,
	0xb6, 0x09, 0xaf, 0xa0, 0x62, 0x4a, 0x9b, 0x88, 0xc6, 0xe5, 0xd3, 0xd3, 0x56, 0xcc, 0x8a, 0xc8,
	0x05, 0x34, 0x63, 0x33, 0xbe, 0xe2, 0x32, 0xb9, 0x17, 0x26, 0x1f, 0xb1, 0x86, 0xe5, 0x7c, 0x4d,
	0x91, 0x17, 0xd0, 0x8a, 0x45, 0x92, 0x09, 0x91, 0xaf, 0x32, 0x55, 0xf0, 0x42, 0xc4, 0xed, 0x72,
	0x07, 0xf5, 0x2a, 0xec, 0xfc, 0x48, 0x33, 0xcb, 0x92, 0xf7, 0x80, 0xd7, 0x7c, 0x73, 0x97, 0x64,
	0x6a, 0x2f, 0xe3, 0xd5, 0x46, 0xdd, 0xab, 0xac, 0xed, 0x98, 0x12, 0x4f, 0x1e, 0x95, 0x60, 0x93,
	0x2b, 0x9f, 0xb5, 0x7e, 0xcb, 0x87, 0x5a, 0xdd, 0xfd, 0x8e, 0x00, 0x8f, 0xd2, 0xad, 0x90, 0x79,
	0xaa, 0xe4, 0xbf, 0x2d, 0xf4, 0x12, 0x9c, 0x3c, 0x7d, 0xb0, 0x8b, 0x9c, 0x0a, 0x8e, 0xd2, 0x07,
	0xc1, 0x8c, 0x84, 0x78, 0x50, 0x55, 0xb7, 0xb7, 0xb9, 0x28, 0xcc, 0x3e, 0xa7, 0x9c, 0x17, 0x2a,
	0x95, 0x05, 0x3b, 0xaa, 0xba, 0xef, 0xc0, 0xd1, 0xb5, 0x49, 0x13, 0x50, 0x66, 0xca, 0xb8, 0x0c,
	0x65, 0x1a, 0xd9, 0xdf, 0xe6, 0x32, 0x94, 0x68, 0xb4, 0x36, 0x76, 0x2e, 0x43, 0x6b, 0x8d, 0xb8,
	0x79, 0x02, 0x97, 0x21, 0xde, 0xf7, 0xa1, 0x61, 0xaa, 0x46, 0x6a, 0x9f, 0x6d, 0x04, 0xa9, 0x83,
	0xe3, 0x5f, 0x2f, 0xe7, 0xf8, 0x8c, 0x34, 0xa0, 0x16, 0x0d, 0x7d, 0x4a, 0x03, 0x86, 0x11, 0xc1,
	0xd0, 0x3c, 0x82, 0x15, 0x8d, 0xbe, 0x44, 0xb8, 0x44, 0xfe, 0x83, 0xca, 0x62, 0x3a, 0x5f, 0xce,
	0x71, 0xb9, 0xff, 0x06, 0xdc, 0x3f, 0x2e, 0x41, 0x8f, 0x86, 0xf4, 0xb3, 0x3f, 0x0b, 0x47, 0xf8,
	0x4c, 0x3b, 0x7e, 0x58, 0x04, 0x13, 0x8c, 0x48, 0x0d, 0xca, 0x0b, 0x3a, 0xc1, 0x25, 0x4d, 0x2d,
	0xc3, 0xf1, 0x18, 0x97, 0xfb, 0x21, 0xd4, 0x67, 0x5c, 0x26, 0x7b, 0xfd, 0x48, 0x0d, 0xa8, 0x5d,
	0xd3, 0x8f, 0x74, 0x7e, 0x43, 0x6d, 0x7a, 0x40, 0x27, 0xb3, 0x30, 0x9a, 0x62, 0x64, 0xaa, 0x2c,
	0x7c, 0xaa, 0x41, 0x89, 0x00, 0x54, 0x27, 0x01, 0xfb, 0xe4, 0x53, 0x5c, 0xd6, 0xdf, 0x63, 0x16,
	0xd0, 0xe1, 0x14, 0x3b, 0x57, 0xff, 0x7f, 0x25, 0x8f, 0x4f, 0x7e, 0x5d, 0x35, 0xa7, 0xfe, 0xfa,
	0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0x12, 0x35, 0x1a, 0x34, 0x03, 0x00, 0x00,
}
