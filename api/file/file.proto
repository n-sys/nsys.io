syntax = "proto3";
package nsys.api.file;
option go_package = "nsys.io/api/file";

import "google/longrunning/operations.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "nsys.io/api/ntypes/file_ntypes.proto";

service FileProcessing {
	// Upload a generic file for further processing later.
	rpc UploadGenericFile (UploadGenericFileRequest) 
			returns (UploadGenericFileResponse) {}
	rpc UploadGenericFileLRO (UploadGenericFileRequest) 
			returns (google.longrunning.Operation) {}

	// Group any number of previously-uploaded files together into a 
	// single fileset. Files may have membership in multiple filesets.
	rpc CreateFileset (CreateFilesetRequest)
			returns (CreateFilesetResponse) {}
	rpc CreateFilesetLRO (CreateFilesetRequest)
			returns (google.longrunning.Operation) {}

	// Begin processing the fileset in the specified way.
	// This is a temporary hack (therefore this will be here forever ;-)
	rpc InitiateProcessing(InitiateProcessingRequest)
			returns (google.protobuf.Empty) {}
	rpc InitiateProcessingLRO (InitiateProcessingRequest)
			returns (google.longrunning.Operation) {}

	// Parses an email *.eml file stored as a generic file. Stores all
	// attachments as new generic files and returns the email headers, body,
	// and list of attachments.
	rpc ParseEmail(ParseEmailRequest)
			returns (ParseEmailResponse) {}
	rpc ParseEmailLRO(ParseEmailRequest)
			returns (google.longrunning.Operation) {}

	// Given an email *.eml file stored as a generic file, this renders the
	// email body as a pdf and stores the pdf as a new generic file.
	rpc RenderEmailBody(RenderEmailBodyRequest)
			returns (RenderEmailBodyResponse) {}
	rpc RenderEmailBodyLRO(RenderEmailBodyRequest)
			returns (google.longrunning.Operation) {}
}

message UploadGenericFileRequest {
	// The file's identifier which must be unique within the
        // account and must match the regex '^[0-9A-Za-z.-]{1,48}$'.
        // Automatically generated if not supplied in upload request.
        string name = 1;

	ntypes.GenericFile generic_file = 2;	

	// Requested file expiration time. The time is capped to comply with 
	// account-specific minimums and maximums. A zero value requests the 
	// maximum allowable expiration time be used.
	google.protobuf.Timestamp expire_time = 3;
}

message UploadGenericFileResponse {
	// Identifier for the uploaded file.
	string Name = 1;
	// The actual expiration time for the file.
	google.protobuf.Timestamp expire_time = 2;	
}

message CreateFilesetRequest {
	// The fileset's identifier which must be unique within the
        // account and must match the regex '^[0-9A-Za-z.-]{1,48}$'.
        // Automatically generated if not supplied.
        string name = 1;

	// One or more files that are to become members of the fileset.
	repeated string file_names = 2;

	// Requested fileset expiration time. The time is capped so that it 
	// is no later than the latest expiration time of any file in the set.
	// A zero value requests the maximum allowable expiration time be used.
	google.protobuf.Timestamp expire_time = 3;
}

message CreateFilesetResponse {
	// Identifier for the fileset.
	string Name = 1;
	// The actual expiration time for the fileset.
	google.protobuf.Timestamp expire_time = 2;	
}
	
message InitiateProcessingRequest {
	// Identifier of the object to process.
	string name = 1;
	// Application-specific type of processing to perform.
	string process_code = 2;
}

message ParseEmailRequest{
	// The name of a generic file contaning an eml file
	string eml_name = 1;

	// The source id that the attachments will be linked to
	string source_name = 2;

	// The whitelist of email attachment file extensions to save, things like:
	// ".pdf", ".png", ".tif", ".tiff", ".jpg", ".jpeg". If empty, then no
	// attachments will be saved. In any case a list of rejected attachments
	// will be returned.
	repeated string attachment_whitelist = 3;
}

message ParseEmailResponse{
	// The email headers
	map<string, string> headers = 1;

	// The email body (html/text)
	string email_body = 2;

	// The saved attachment generic file IDs
	repeated ntypes.EmailAttachment attachments = 3;

	// The attachments that were rejected due to their file extensions not
	// being in the given whitelist.
	repeated ntypes.EmailAttachment rejected_attachments = 4;
}

message RenderEmailBodyRequest {
	// The name of a generic file contaning an eml file
	string eml_name = 1;

	// The source id that the rendered email will be linked to
	string source_name = 2;

	// The whitelist of inline email attachments to include in the rendering,
	// things like: ".jpg", ".jpeg", ".png", ".gif". If empty, then no inline
	// attachments will be rendered in the email body.
	repeated string inline_attachment_whitelist = 3;
}

message RenderEmailBodyResponse {
	// The generic file ID of the rendered email pdf
	string email_pdf_name = 1;
}